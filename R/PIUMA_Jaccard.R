#' @title Compute the Matrix of Jaccard Indexes
#'
#' @description This function computes the Jaccard index for each pair of
#' rows contained in the data.frame, generated by the  \code{\link{mapperCore}}
#' funtion. The resulting data.frame can be used to represent data as a
#' network, for intance, in Cytoscape
#'
#' @param dfMapper A data.frame generated by the  \code{\link{mapperCore}}
#' function.
#'
#' @return A matrix of Jaccard indexes between each pair of rows, contained in
#'  the data.frame, generated by the  \code{\link{mapperCore}}
#' funtion
#'
#' @details The Jaccard index measures the similarity of two nodes A and B.
#' It ranges from 0 to 1. If A and B share no members, their Jaccard index
#' would be 0 (= NA). If A and B share all members, their Jaccard index would
#' be 1. Hence, the higher the index, the more similar the
#' two nodes. If the Jaccard index between A and B is different from NA, it
#' means that an edge exists between A and B. The output matrix of Jaccard
#' indexes can be used as an adjacency matrix. The resulting data.frame can 
#' be used to represent data as a network, for intance, in Cytoscape.
#'
#' @author Laura Ballarini, Mattia Chiesa
#'
#' @examples
#' ## use example data:
#' data(dfMapper_tda)
#' jacc_mat <- jaccardMatrix(dfMapper_tda)
#'
#' @seealso
#' \code{\link{importSplitScale}},
#' \code{\link{dfToDistance}},
#' \code{\link{dfToProjection}},
#' \code{\link{mapperCore}}
#'
#' @export
#'
#'
jaccardMatrix <- function (dfMapper) {

  # inner function for jaccard computation--------------------------------------
  jaccard <- function(a, b) {
    intersection <- length(intersect(a, b))
    union <- length(a) + length(b) - intersection
    return (intersection/union)
  }

  # checks----------------------------------------------------------------------
  # check missing arguments
  if (missing(dfMapper))
    stop("'dfMapper' argument must be provided")

  # check the type of argument
  if (!is.data.frame(dfMapper))
    stop("'dfMapper' argument must be a data.frame")

  # specific checks
  if (dim(dfMapper)[2] != 1)
    stop("dim(dfMapper)[2] must be equal to 1")

  if (!all(vapply(dfMapper, class, FUN.VALUE=character(1)) %in% "character"))
    stop("'dfMapper' elements must be of type 'character'")

  # check the presence of NA or Inf
  if (any(is.na(dfMapper)))
    stop("NA values are not allowed in the 'dfMapper' data.frame")

  if (any(is.infinite(as.matrix(dfMapper))))
    stop("Inf values are not allowed in the 'dfMapper' data.frame")

  # body------------------------------------------------------------------------

  jaccDataRes <- matrix(nrow = nrow(dfMapper),ncol=nrow(dfMapper))
  colnames(jaccDataRes) <- rownames(jaccDataRes) <- rownames(dfMapper)

  # computation of the returned matrix (i.e. 'jaccDataRes')
  for (i in seq_len(nrow(dfMapper))) {
    for (j in seq_len(nrow(dfMapper))) {

      listDfRowElem1 <- unlist(strsplit(dfMapper[i,1], " "))
      listDfRowElem2 <- unlist(strsplit(dfMapper[j,1], " "))

      if(jaccard(listDfRowElem1,listDfRowElem2) != 0) {
        jaccDataRes[i,j] <-  jaccDataRes[j,i] <- jaccard(listDfRowElem1,
                                                         listDfRowElem2)
      }
    }
  }

  diag(jaccDataRes) <- NA
  return(jaccDataRes)
}
